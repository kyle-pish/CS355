(* frontend.ml
 * A front end (lexer) for the CS355 Scheme-- language.
 * Author: Mark Liffiton
 * Date: October 2022
 *)

(* Disable the deprecation alerts ocamlc will throw for Genlex and Stream.
 * It's okay.  We don't want to use an external library, so the old versions in
 * the standard library are fine.
 *)
[@@@warning "-3"]

(* Variant type for atoms *)
type atomtype =
    | Keyword of string
    | Number of float
    | String of string
    | Identifier of string  (* a variable name *)

(* Variant type for AST nodes.  Each is either an atom or an expression. *)
type ast_node =
    | Atom of atomtype
    | Expr of ast_node list

(* Define a new type of exception just for breaking out of our while loop. *)
exception LoopBreak

(* Define a lexer with the specific syntax keywords of Scheme--. *)
let lexer = Genlex.make_lexer [ "("; ")"; "run"; "print"; "let"; "lambda"; "call"; "if"; ">"; "<"; "=="; "+"; "-"; "*"; "/" ]

(* parse
 * Arguments:
 *  - stream: A Stream of tokens generated by our lexer.
 * Returns:
 *  - A single Expr (from the ast_node variant) of the one expression for the parsed program.
 *
 * Note that a valid Scheme-- program must be a single expression.
 *)
let rec parse stream =
    (* "ref"?  A while loop?  ":="?  Putting "!" in front of variables?  What is this?!
     * ...
     * Um, don't worry about it.  I'm being decidedly non-functional here...
     *)
    let l = ref [] in
    try
        while true do
            let next = Stream.next stream in
            let exp = begin
                match next with
                | Genlex.Kwd "(" -> parse stream
                | Genlex.Kwd ")" -> raise LoopBreak
                | Genlex.Kwd x -> Atom (Keyword x)
                | Genlex.Ident x -> Atom (Identifier x)
                | Genlex.Int x -> Atom (Number (float_of_int x))
                | Genlex.Float x -> Atom (Number x)
                | Genlex.String x -> Atom (String x)
                | _ -> failwith "Parsing error!  Unexpected atom."
            end in
            l := exp :: !l
        done ;
        assert false  (* Should never get here, only exit the loop via exceptions. *)
    with
    | LoopBreak -> Expr (List.rev !l)
    | Stream.Failure -> match !l with
        (* Assume Stream.Failure happens only at the top level of recursion,
         * and ensure there is only one expression at the top level.
         *)
        | hd :: [] -> hd
        | hd :: tl -> failwith "Parsing error!  Too many expressions at top level."
        | [] -> failwith "Parsing error!  No expression found."

(* parse_file
 * Parse a program from a file into an AST.
 *
 * Arguments:
 *  - filename: A string containing the name of the file to be read and parsed.
 * Returns:
 *  - A single Expr (from the ast_node variant) of the one expression for the parsed program.
 *
 * Note that a valid Scheme-- program must be a single expression.
 *)
let parse_file (filename : string) =
    open_in filename |> Stream.of_channel |> lexer |> parse
    (* equivalent to:
    let channel = open_in filename in
    let stream = Stream.of_channel channel in
    let stream_atoms = lexer stream in
    parse stream_atoms
    * Look up the |> operator if you're curious.
    *)

(* string_of_ast
 * Convert an AST node into a string representation.
 *
 * Arguments:
 *  - ast: Any ast_node.
 * Returns:
 *  - A string representation, formatted nicely, for the given AST node.
 *    Ends with a newline character.
 *)
let string_of_ast (ast : ast_node) =
    let rec indent amount =
        if amount = 0 then "" else ( "  " ^ indent (amount - 1) )
    in
    let rec string_of_ast_helper lvl ast =
        match ast with
        | Atom x ->
            " " ^ begin
                match x with
                | Keyword x | Identifier x -> x
                | String x -> "\"" ^ x ^ "\""
                | Number x -> string_of_float x
            end
        | Expr lst ->
            begin
                if lvl > 0 then
                    "\n" ^ indent lvl
                else
                    ""
            end
            ^ "["
            ^ List.fold_left (^) "" (List.map (string_of_ast_helper (lvl + 1)) lst)
            ^ " ]"
    in
    string_of_ast_helper 0 ast ^ "\n"

(* print_ast
 * Print an AST node, formatting it nicely, ending with a newline character.
 *
 * Arguments:
 *  - ast: Any ast_node.
 * Returns:
 *  - Unit (none)
 *)
let print_ast (ast : ast_node) =
    print_string (string_of_ast ast)

